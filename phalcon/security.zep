
/*
 +------------------------------------------------------------------------+
 | Phalcon Framework                                                      |
 +------------------------------------------------------------------------+
 | Copyright (c) 2011-2013 Phalcon Team (http://www.phalconphp.com)       |
 +------------------------------------------------------------------------+
 | This source file is subject to the New BSD License that is bundled     |
 | with this package in the file docs/LICENSE.txt.                        |
 |                                                                        |
 | If you did not receive a copy of the license and are unable to         |
 | obtain it through the world-wide-web, please send an email             |
 | to license@phalconphp.com so we can send you a copy immediately.       |
 +------------------------------------------------------------------------+
 | Authors: Andres Gutierrez <andres@phalconphp.com>                      |
 |          Eduar Carvajal <eduar@phalconphp.com>                         |
 +------------------------------------------------------------------------+
 */

namespace Phalcon;

/**
 * Phalcon\Security
 *
 * This component provides a set of functions to improve the security in Phalcon applications
 *
 *<code>
 *	$login = $this->request->getPost('login');
 *	$password = $this->request->getPost('password');
 *
 *	$user = Users::findFirstByLogin($login);
 *	if ($user) {
 *		if ($this->security->checkHash($password, $user->password)) {
 *			//The password is valid
 *		}
 *	}
 *</code>
 */
class Security //implements Phalcon\Di\InjectionAwareInterface
{

	protected _dependencyInjector;

	protected _workFactor = 8 {set, get};

	protected _numberBytes = 16;

	protected _csrf;

	/**
	* Sets the dependency injector
	*
	* @param Phalcon\DiInterface $dependencyInjector
	*/
	public function setDI(<Phalcon\DiInterface> dependencyInjector) -> void
	{
		let this->_dependencyInjector = dependencyInjector;
	}

	/**
	* Returns the internal dependency injector
	*
	* @return Phalcon\DiInterface
	*/
	public function getDI() -> <Phalcon\DiInterface>
	{
		return this->_dependencyInjector;
	}

	/**
	* Sets a number of bytes to be generated by the openssl pseudo random generator
	*
	* @param string $randomBytes
	*/
	public function setRandomBytes(randomBytes) -> void
	{
		if typeof randomBytes != "long" {
			throw new Phalcon\Security\Exception("At least 16 bytes are needed to produce a correct salt");
		}

		let this->_numberBytes = randomBytes;
	}

	/**
	* Returns a number of bytes to be generated by the openssl pseudo random generator
	*
	* @return string
	*/
	public function getRandomBytes() -> string
	{
		return this->_numberBytes;
	}

	/**
	* Generate a >22-length pseudo random string to be used as salt for passwords
	*
	* @return string
	*/
	public function getSaltBytes() -> string
	{
		var numberBytes, randomBytes, safeBytes, bytesLength, base64Bytes, filter;

		if !function_exists("openssl_random_pseudo_bytes") {
			throw new Phalcon\Security\Exception("Openssl extension must be loaded");
		}

		let numberBytes = this->_numberBytes;

		while(1)
		{
			let randomBytes = openssl_random_pseudo_bytes(numberBytes);
			let base64Bytes = base64_encode(randomBytes);
			let filter = new Phalcon\Filter();
			let safeBytes = filter->sanitize(base64Bytes, "alphnum"); 
			
			if !safeBytes {
				continue;
			}

			let bytesLength = strlen(safeBytes);
			if bytesLength < 22 {
				continue;
			}

			break;
		}

		return safeBytes;
	}

	/**
	* Creates a password hash using bcrypt with a pseudo random salt
	*
	* @param string $password
	* @param int $workFactor
	* @return string
	*/
	public function hash(string password, workFactor) -> string
	{
		var factor, saltBytes, salt;

		if !workFactor {
			let workFactor = this->_workFactor;
		}

		let factor = sprintf("%02s", workFactor);
		let saltBytes = this->getSaltBytes();
		let salt = "$2a$" . factor . "$" . saltBytes;

		return crypt(password, salt);
	}

	/**
	* Checks a plain text password and its hash version to check if the password matches
	*
	* @param string $password
	* @param string $passwordHash
	* @param int $maxPasswordLength
	* @return boolean
	*/
	public function checkHash(string password, string passwordHash, int maxPassLength)
	{
		var hash;

		if maxPassLength {
			if maxPassLength > 0 && count(password) > maxPassLength {
				return false;
			}
		}

		let hash = crypt(password, passwordHash);

		if hash == passwordHash {
			return true;
		} else {
			return false;
		}
	}

	/**
	* Checks if a password hash is a valid bcrypt's hash
	*
	* @param string $password
	* @param string $passwordHash
	* @return boolean
	*/
	public function isLegacyHash(string password, string passwordHash)
	{
		if starts_with_str(passwordHash, "$2a$") {
			return true;
		} 	
		return false;
	}

	/**
	* Generates a pseudo random token key to be used as input's name in a CSRF check
	*
	* @param int $numberBytes
	* @return string
	*/
	public function getTokenKey(int numberBytes) -> string
	{
		var randomBytes, base64Bytes, filter, safeBytes, dependencyInjector, session;

		if !numberBytes {
			let numberBytes = 12;
		}

		if !function_exists("openssl_random_pseudo_bytes") {
			throw new Phalcon\Security\Exception("Openssl extension must be loaded");
		}

		let randomBytes = openssl_random_pseudo_bytes(numberBytes);
		let base64Bytes = base64_encode(randomBytes);
		let filter = new Phalcon\Filter();
		let safeBytes = filter->sanitize(base64Bytes, "alphnum"); 
		let dependencyInjector = this->_dependencyInjector;
		
		if typeof dependencyInjector != "object" {
			throw new Phalcon\Security\Exception("A dependency injection container is required to access the 'session' service");
		}

		let session = dependencyInjector->getShared("session");
		session->set("$PHALCON/CSRF/KEY$", safeBytes);

		return safeBytes;
	}

	/**
	* Generates a pseudo random token value to be used as input's value in a CSRF check
	*
	* @param int $numberBytes
	* @return string
	*/
	public function getToken(int numberBytes=null) -> string
	{
		var token, dependencyInjector, session;

		if !numberBytes {
			let numberBytes = 12;
		}

		if !function_exists("openssl_random_pseudo_bytes") {
			throw new Phalcon\Security\Exception("Openssl extension must be loaded");
		}

		let token = openssl_random_pseudo_bytes(numberBytes);
		let dependencyInjector = this->_dependencyInjector;
		
		if typeof dependencyInjector != "object" {
			throw new Phalcon\Security\Exception("A dependency injection container is required to access the 'session' service");
		}

		let session = dependencyInjector->getShared("session");
		session->set("$PHALCON/CSRF/KEY$", token);

		return token;
	}

	/**
	* Check if the CSRF token sent in the request is the same that the current in session
	*
	* @param string $tokenKey
	* @param string $tokenValue
	* @return boolean
	*/
	public function checkToken(tokenKey=null, tokenValue=null)
	{
		var dependencyInjector, session, request, token, sessionToken;

		let dependencyInjector = this->_dependencyInjector;
		
		if typeof dependencyInjector != "object" {
			throw new Phalcon\Security\Exception("A dependency injection container is required to access the 'session' service");
		}

		let session = dependencyInjector->getShared("session");

		if !tokenKey {
			let tokenKey = session->get("$PHALCON/CSRF/KEY$");
		}

		if !tokenValue {
			let request = dependencyInjector->getShared("request");

			/** 
            * We always check if the value is correct in post
            */
            let token = request->getPost(tokenKey);
		} else {
			let token = tokenValue;
		}

		let sessionToken = session->get("$PHALCON/CSRF$");

		/** 
        * The value is the same?
        */
        if token == sessionToken {
        	return true;
        } else {
        	return false;
        }
    }

    /**
	* Returns the value of the CSRF token in session
	*
	* @return string
	*/
	public function getSessionToken() -> string
	{
		var dependencyInjector, session;

		let dependencyInjector = this->_dependencyInjector;
	
		if typeof dependencyInjector != "object" {
			throw new Phalcon\Security\Exception("A dependency injection container is required to access the 'session' service");
		}

		let session = dependencyInjector->getShared("session");
		return session->get("$PHALCON/CSRF$");
	}

	/**
	* string \Phalcon\Security::computeHmac(string $data, string $key, string $algo, bool $raw = false)
	*/
	public function computeHmac(data, key, algo, raw=false)
	{
		var ops;

		let ops = hash_hmac(algo, algo, key, raw);
		if !ops {
			throw new Phalcon\Security\Exception("Unknown hashing algorithm: %s" . algo);
		}

		return ops;
	}


}
